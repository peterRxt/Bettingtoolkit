<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>FootyStats Match Filter</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root {
      --primary: #2563eb;
      --primary-dark: #1e40af;
      --danger: #ef4444;
      --danger-dark: #b91c1c;
      --bg: #f3f4f6;
      --white: #fff;
      --shadow: 0 2px 24px rgba(0,0,0,0.08);
      --radius: 18px;
      --spacing: 18px;
      --font: 'Inter', Arial, sans-serif;
      --transition: 0.18s cubic-bezier(.4,0,.2,1);
      --odds-green: #bbf7d0;
      --odds-yellow: #fef9c3;
    }
    body {
      font-family: var(--font);
      margin: 0;
      background: var(--bg);
      min-height: 100vh;
      color: #222;
    }
    .container {
      max-width: 900px;
      margin: 28px auto;
      background: var(--white);
      box-shadow: var(--shadow);
      padding: var(--spacing);
      border-radius: var(--radius);
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    h2 {
      font-weight: 700;
      letter-spacing: -1px;
      margin-bottom: 0.3em;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .controls label {
      font-size: 1.07em;
      font-weight: 500;
      margin-right: 7px;
    }
    input[type="number"], input[type="file"], input[type="text"] {
      font-size: 1em;
      padding: 8px 14px;
      border: 1.5px solid #e5e7eb;
      border-radius: 6px;
      background: #f9fafb;
      transition: border var(--transition);
      outline: none;
      min-width: 64px;
      box-sizing: border-box;
    }
    input[type="number"]:focus, input[type="file"]:focus, input[type="text"]:focus {
      border-color: var(--primary);
    }
    button {
      font-size: 1em;
      font-weight: 500;
      padding: 10px 18px;
      border-radius: 7px;
      border: none;
      cursor: pointer;
      background: var(--primary);
      color: var(--white);
      transition: background var(--transition), box-shadow var(--transition);
      box-shadow: 0 1px 7px 0 rgba(37,99,235,0.04);
    }
    button:active {
      background: var(--primary-dark);
    }
    button:disabled {
      background: #cbd5e1;
      color: #888;
      cursor: not-allowed;
    }
    .export-btn {
      background: #059669;
      margin-left: auto;
    }
    .export-btn:active {
      background: #047857;
    }
    .delete-btn {
      background: var(--danger);
      color: var(--white);
      font-size: 0.98em;
      padding: 7px 12px;
      border-radius: 5px;
      transition: background var(--transition);
    }
    .delete-btn:hover, .delete-btn:active {
      background: var(--danger-dark);
    }
    .odds-input {
      width: 75px;
      padding: 5px 7px;
      border: 1.5px solid #d1d5db;
      border-radius: 5px;
      background: #f8fafc;
      font-size: 1em;
    }
    .status, .err {
      margin: 0 0 4px 0;
      font-size: 1rem;
      padding: 8px 0 2px 0;
      min-height: 1em;
    }
    .status {
      color: #059669;
    }
    .err {
      color: var(--danger);
    }
    .progress-bar {
      height: 8px;
      background: #e0e7ef;
      border-radius: 5px;
      overflow: hidden;
      margin: 7px 0;
      width: 100%;
      position: relative;
      display: none;
    }
    .progress-bar.active {
      display: block;
    }
    .progress-inner {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg,#2563eb,#38bdf8 80%);
      transition: width 0.15s linear;
    }
    #preview-table {
      margin-top: 16px;
      overflow-x: auto;
      max-width: 100vw;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      min-width: 660px;
      background: #f8fafc;
      margin: 0;
    }
    th, td {
      border: 1px solid #e5e7eb;
      padding: 10px 7px;
      text-align: center;
      font-size: 1em;
    }
    th {
      background: var(--primary);
      color: var(--white);
    }
    tr:nth-child(even) td {
      background: #f1f5f9;
    }
    .accum-odds {
      margin-top: 12px;
      font-size: 1.14em;
      font-weight: 600;
      color: #059669;
    }
    #timestamp {
      font-size: 0.94em;
      color: #888;
      margin-top: 8px;
      text-align: right;
    }
    .odds-green { background: var(--odds-green) !important; }
    .odds-yellow { background: var(--odds-yellow) !important; }
    @media (max-width: 650px) {
      .container {
        border-radius: 0;
        max-width: 100vw;
        padding: 2vw 0.6vw 10vw 0.6vw;
      }
      h2 { font-size: 1.3em; }
      .controls {
        flex-direction: column;
        align-items: flex-start;
        gap: 13px;
      }
      table {
        font-size: 0.95em;
        min-width: 540px;
      }
    }
    @media (max-width: 430px) {
      .container { padding: 2vw 0.2vw 8vw 0.2vw; }
      table { font-size: 0.89em; }
      th, td { padding: 7px 3px; }
      .accum-odds { font-size: 1em; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>FOOTYSTATS</h2>
    <H1>BEST FILTER FROM 1.5</H1>
    <div class="status" id="status"></div>
    <div class="err" id="err"></div>
    <div class="progress-bar" id="progressBar"><div class="progress-inner" id="progressInner"></div></div>
    <div class="controls">
      <input type="file" id="htmlInput" accept=".html,.htm">
      <label>
        ENTER VALUE
        <input type="number" id="formDiffInput" value="0" step="0.01">
      </label>
      <!-- TIME INTERVAL FILTER -->
      <label>
        Time Interval (24hr): 
        <input type="text" id="startTimeInput" placeholder="e.g. 0000">
        to
        <input type="text" id="endTimeInput" placeholder="e.g. 1100">
      </label>
      <button id="filterBtn" disabled>Filter</button>
      <button class="export-btn" id="exportBtn" disabled>Export to PNG</button>
    </div>
    <div id="preview-table"></div>
    <div id="timestamp"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script>
    let matches = [], filtered = [], isParsing = false, parseAbort = false;

    const htmlInput = document.getElementById('htmlInput');
    const filterBtn = document.getElementById('filterBtn');
    const exportBtn = document.getElementById('exportBtn');
    const formDiffInput = document.getElementById('formDiffInput');
    // TIME INTERVAL FILTER
    const startTimeInput = document.getElementById('startTimeInput');
    const endTimeInput = document.getElementById('endTimeInput');
    const previewTable = document.getElementById('preview-table');
    const errDiv = document.getElementById('err');
    const statusDiv = document.getElementById('status');
    const progressBar = document.getElementById('progressBar');
    const progressInner = document.getElementById('progressInner');
    const timestampDiv = document.getElementById('timestamp');

    function showStatus(msg) { statusDiv.textContent = msg; }
    function showError(msg) { errDiv.textContent = msg; }
    function clearStatus() { statusDiv.textContent = ""; }
    function clearError() { errDiv.textContent = ""; }
    function setProgress(val) {
      progressBar.classList.add('active');
      progressInner.style.width = (val * 100) + "%";
      if (val >= 1 || val === 0) setTimeout(() => progressBar.classList.remove('active'), 400);
    }

    htmlInput.addEventListener('change', async function(event) {
      const file = event.target.files[0];
      if (!file) return;
      matches = filtered = [];
      clearError();
      clearStatus();
      previewTable.innerHTML = '';
      timestampDiv.textContent = '';
      filterBtn.disabled = true;
      exportBtn.disabled = true;

      if (file.size > 10 * 1024 * 1024) { // 10MB
        showStatus("Large file detected. Parsing may take a while.");
      }
      parseAbort = false;
      isParsing = true;
      setProgress(0);
      await parseFootyStatsLargeFile(file);
    });

    async function parseFootyStatsLargeFile(file) {
      try {
        showStatus("Parsing file...");
        let chunkSize = 1024 * 1024; // 1MB
        let total = file.size, loaded = 0, html = '';
        let reader = file.stream().getReader();
        let decoder = new TextDecoder();
        while (true) {
          if (parseAbort) { showError("Parsing cancelled."); return; }
          const {done, value} = await reader.read();
          if (done) break;
          loaded += value.length;
          html += decoder.decode(value, {stream:true});
          setProgress(loaded / total);
        }
        html += decoder.decode(); // flush
        setProgress(1);
        await new Promise(res=>setTimeout(res, 100)); // let progress bar fill
        parseFootyStats(html);
      } catch (e) {
        showError("Failed to parse file: " + e.message);
      } finally {
        isParsing = false;
        setProgress(0);
      }
    }

    htmlInput.addEventListener('click', function(){ if(isParsing) parseAbort = true; });

    function parseFootyStats(html) {
      matches = [];
      clearError();
      showStatus("Parsing matches...");
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const matchLinks = doc.querySelectorAll('a.match.row');
      if (!matchLinks.length) {
        showError("No matches found. Is this a FootyStats HTML?");
        filterBtn.disabled = true;
        exportBtn.disabled = true;
        clearStatus();
        return;
      }
      let i = 0;
      function parseBatch() {
        let batchCount = 80, count = 0;
        for (; i < matchLinks.length && count < batchCount; ++i, ++count) {
          const match = matchLinks[i];
          const homeTeam = match.querySelector('.team.home span')?.textContent.trim() || '';
          const homeForm = parseFloat(match.querySelector('.team.home .form-box')?.textContent.trim() || '0');
          const awayTeam = match.querySelector('.team.away span')?.textContent.trim() || '';
          const awayForm = parseFloat(match.querySelector('.team.away .form-box')?.textContent.trim() || '0');
          let time = '', dateDiv = match.querySelector('.date, [data-time]');
          if (dateDiv) {
            if (dateDiv.dataset.time) {
              try {
                let t = parseInt(dateDiv.dataset.time);
                if (!isNaN(t)) {
                  const d = new Date(t * 1000);
                  time = d.toLocaleString();
                }
              } catch {}
            }
            if (!time) time = dateDiv.textContent.trim();
          }
          let oddsSpans = match.querySelectorAll('.stat.odds .hover-modal-parent');
          let homeOdds = '', drawOdds = '', awayOdds = '';
          if (oddsSpans.length >= 3) {
            homeOdds = oddsSpans[0].childNodes[0]?.nodeType === 3 ? oddsSpans[0].childNodes[0].textContent.trim() : oddsSpans[0].textContent.trim();
            drawOdds = oddsSpans[1].childNodes[0]?.nodeType === 3 ? oddsSpans[1].childNodes[0].textContent.trim() : oddsSpans[1].textContent.trim();
            awayOdds = oddsSpans[2].childNodes[0]?.nodeType === 3 ? oddsSpans[2].childNodes[0].textContent.trim() : oddsSpans[2].textContent.trim();
            if (!parseFloat(homeOdds)) homeOdds = oddsSpans[0].textContent.match(/[\d.]+/)?.[0] || '';
            if (!parseFloat(drawOdds)) drawOdds = oddsSpans[1].textContent.match(/[\d.]+/)?.[0] || '';
            if (!parseFloat(awayOdds)) awayOdds = oddsSpans[2].textContent.match(/[\d.]+/)?.[0] || '';
          }
          if (!homeOdds || !drawOdds || !awayOdds) {
            let oddsNums = Array.from(match.querySelectorAll('.stat.odds')).map(x => x.textContent.match(/[\d.]+/g)).flat().filter(Boolean);
            if (oddsNums.length >= 3) [homeOdds, drawOdds, awayOdds] = oddsNums.slice(0, 3);
          }
          if (homeTeam && awayTeam) {
            matches.push({
              home: homeTeam, homeForm, away: awayTeam, awayForm, time,
              homeOdds: parseFloat(homeOdds), drawOdds: parseFloat(drawOdds), awayOdds: parseFloat(awayOdds)
            });
          }
        }
        if (i < matchLinks.length) {
          setProgress(i / matchLinks.length);
          showStatus(`Parsing matches... (${i}/${matchLinks.length})`);
          setTimeout(parseBatch, 0);
        } else {
          showStatus("Matches loaded! Set a filter and click Filter.");
          filterBtn.disabled = false;
          exportBtn.disabled = true;
          previewTable.innerHTML = '<em>Table loaded, enter filter and click Filter.</em>';
          timestampDiv.textContent = '';
          setProgress(1);
          setTimeout(()=>setProgress(0), 500);
        }
      }
      parseBatch();
    }

    function getWinningOdds(match) {
      if (match.homeForm > match.awayForm) return { team: match.home, odds: match.homeOdds };
      else if (match.awayForm > match.homeForm) return { team: match.away, odds: match.awayOdds };
      else return { team: 'Draw', odds: match.drawOdds };
    }

    // Parse a time string "16:00", "1600", "4:00 pm", etc. to minutes since midnight
    function parseTimeToMinutes(timeStr) {
      if (!timeStr) return null;
      // Try to extract HH:MM
      let m = timeStr.match(/(\d{1,2}):(\d{2})/);
      if (m) {
        return parseInt(m[1],10)*60 + parseInt(m[2],10);
      }
      // Try to extract 4-digit time, e.g. 1600, 0930
      m = timeStr.match(/(\d{2})(\d{2})/);
      if (m && m[0].length === 4) {
        return parseInt(m[1],10)*60 + parseInt(m[2],10);
      }
      // Try AM/PM
      m = timeStr.match(/(\d{1,2}):(\d{2})\s*(am|pm)/i);
      if (m) {
        let h = parseInt(m[1],10), min = parseInt(m[2],10);
        if (/pm/i.test(m[3]) && h < 12) h += 12;
        if (/am/i.test(m[3]) && h === 12) h = 0;
        return h*60 + min;
      }
      return null;
    }

    function getOddsClass(odds) {
      if (!odds || isNaN(odds) || odds <= 0) return "";
      if (odds < 1.5) return "odds-green";
      return "odds-yellow";
    }

    filterBtn.addEventListener('click', function () {
      let formDiff = Number(formDiffInput.value);

      // TIME INTERVAL FILTER
      let startTimeRaw = startTimeInput.value.trim();
      let endTimeRaw = endTimeInput.value.trim();
      let startTimeMinutes = null, endTimeMinutes = null;
      if (startTimeRaw) {
        if (/^\d{4}$/.test(startTimeRaw)) {
          startTimeMinutes = parseInt(startTimeRaw.slice(0,2),10)*60 + parseInt(startTimeRaw.slice(2),10);
        } else if (/^\d{1,2}:\d{2}$/.test(startTimeRaw)) {
          let [h,m] = startTimeRaw.split(':');
          startTimeMinutes = parseInt(h,10)*60 + parseInt(m,10);
        }
      }
      if (endTimeRaw) {
        if (/^\d{4}$/.test(endTimeRaw)) {
          endTimeMinutes = parseInt(endTimeRaw.slice(0,2),10)*60 + parseInt(endTimeRaw.slice(2),10);
        } else if (/^\d{1,2}:\d{2}$/.test(endTimeRaw)) {
          let [h,m] = endTimeRaw.split(':');
          endTimeMinutes = parseInt(h,10)*60 + parseInt(m,10);
        }
      }

      filtered = [];
      for (const m of matches) {
        if (m.home.includes('(') || m.home.includes(')') || m.away.includes('(') || m.away.includes(')')) {
          continue;
        }
        let diff = Math.abs(m.homeForm - m.awayForm);

        // TIME INTERVAL FILTER
        if (startTimeMinutes !== null || endTimeMinutes !== null) {
          let matchMins = parseTimeToMinutes(m.time);
          if (matchMins === null) continue;
          if (startTimeMinutes !== null && matchMins < startTimeMinutes) continue;
          if (endTimeMinutes !== null && matchMins > endTimeMinutes) continue;
        }

        if (diff >= formDiff) {
          let winning = getWinningOdds(m);
          filtered.push({
            teams: `${m.home} vs ${m.away}`,
            time: m.time,
            formDiff: diff,
            winningTeam: winning.team,
            winningOdds: winning.odds
          });
        }
      }
      filtered.sort((a, b) => b.formDiff - a.formDiff);
      renderTable();
      showStatus(filtered.length ? "Filtered " + filtered.length + " matches." : "No matches found for this filter.");
    });

    function renderTable() {
      if (filtered.length === 0) {
        previewTable.innerHTML = '<em>No matches found for filter.</em>';
        exportBtn.disabled = true;
        timestampDiv.textContent = '';
        return;
      }
      let html = `<table id="result-table">
        <tr>
          <th>#</th>
          <th>Teams</th>
          <th>Time</th>
          <th>Form Diff</th>
          <th>Winning Odds</th>
          <th>Action</th>
        </tr>`;
      filtered.forEach((f, index) => {
        const isValidOdds = !isNaN(f.winningOdds) && f.winningOdds > 0;
        const oddsDisplay = isValidOdds
          ? `<b>${f.winningTeam}</b>: ${f.winningOdds}`
          : `<b>${f.winningTeam}</b>: <input type="number" step="0.01" min="1.01" class="odds-input" data-index="${index}" placeholder="Enter odds">`;
        const oddsClass = isValidOdds ? getOddsClass(f.winningOdds) : "";
        html += `<tr data-index="${index}">
          <td>${index + 1}</td>
          <td>${f.teams}</td>
          <td>${f.time}</td>
          <td>${f.formDiff.toFixed(2)}</td>
          <td class="${oddsClass}">${oddsDisplay}</td>
          <td><button class="delete-btn" data-index="${index}">Delete</button></td>
        </tr>`;
      });
      html += `</table>`;
      const totalOdds = filtered.reduce((acc, f) => {
        const val = parseFloat(f.winningOdds);
        return acc * (isNaN(val) || val <= 0 ? 1 : val);
      }, 1).toFixed(2);
      html += `<div class="accum-odds"><span>Accumulated Odds:</span> <span id="accumulated-odds">${totalOdds}</span></div>`;
      previewTable.innerHTML = html;
      exportBtn.disabled = false;
      timestampDiv.textContent = 'Updated: ' + (new Date()).toLocaleString();
      document.querySelectorAll('.delete-btn').forEach(btn => {
        btn.addEventListener('click', function () {
          let idx = parseInt(this.getAttribute('data-index'));
          if (!isNaN(idx)) {
            filtered.splice(idx, 1);
            filtered.sort((a, b) => b.formDiff - a.formDiff);
            renderTable();
          }
        });
      });
      document.querySelectorAll('.odds-input').forEach(input => {
        input.addEventListener('input', function () {
          const idx = parseInt(this.getAttribute('data-index'));
          const val = parseFloat(this.value);
          if (!isNaN(idx) && !isNaN(val) && val > 0) {
            filtered[idx].winningOdds = val;
            updateAccumulatedOdds();
          }
        });
      });
    }

    function updateAccumulatedOdds() {
      const total = filtered.reduce((acc, f) => {
        const val = parseFloat(f.winningOdds);
        return acc * (isNaN(val) || val <= 0 ? 1 : val);
      }, 1).toFixed(2);
      const oddsDisplay = document.getElementById('accumulated-odds');
      if (oddsDisplay) oddsDisplay.textContent = total;
    }

    exportBtn.addEventListener('click', function () {
      let table = document.getElementById('result-table');
      if (!table) return;
      let tableClone = table.cloneNode(true);
      tableClone.style.width = "auto";
      tableClone.style.minWidth = "660px";
      tableClone.style.background = "#fff";
      let accum = document.querySelector('.accum-odds');
      let accumClone = accum ? accum.cloneNode(true) : null;
      let tsText = timestampDiv.textContent;
      let wrap = document.createElement('div');
      wrap.style.background = "#fff";
      wrap.style.padding = "18px";
      wrap.style.borderRadius = "10px";
      wrap.style.position = "fixed";
      wrap.style.top = "-9999px";
      wrap.style.left = "-9999px";
      wrap.style.zIndex = "9999";
      wrap.style.width = "max-content";
      wrap.style.maxWidth = "none";
      wrap.style.boxSizing = "border-box";
      wrap.appendChild(tableClone);
      if (accumClone) wrap.appendChild(accumClone);
      let ts = document.createElement('div');
      ts.style.marginTop = "10px";
      ts.style.fontSize = "13px";
      ts.style.color = "#666";
      ts.textContent = tsText;
      wrap.appendChild(ts);
      document.body.appendChild(wrap);
      html2canvas(wrap, {backgroundColor: "#fff", scale: 2}).then(canvas => {
        let link = document.createElement('a');
        link.download = 'filtered_matches.png';
        link.href = canvas.toDataURL();
        link.click();
        document.body.removeChild(wrap);
      });
    });
  </script>
</body>
</html>
